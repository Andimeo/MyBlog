title: 理解Node.js中的事件轮询
date: 2014-06-21 00:34:00
categories:
- Node.js
tags:
- Node.js
- 事件轮询
- 译文
---
{% blockquote %}
本文翻译自Mixu的文章[Understanding the Node.js event loop](http://blog.mixu.net/2011/02/01/understanding-the-node-js-event-loop/)
{% endblockquote %}
**Node.js的第一个基本观点是，I/O是昂贵的。**  

* L1-cache: 3 cycles
* L2-cache: 14 cycles
* RAM: 250 cycles
* Disk: 41 000 000 cycles
* Network: 240 000 000 cycles


所以现在编程技术中最大的浪费来自对I/O的等待。我们有几种方法用来可以应对I/O：

1. 同步：按序执行每一个请求。优点：简单。缺点：任何一个请求都可能会阻塞其他请求。
2. 进程：对每个请求，我们都开一个新的进程来处理。优点：容易。缺点：扩展性不好，有几百个请求的话，就需要几百个进程来处理。fork()是Unix程序员的万精油。因为它的使用，所有问题看起来都微不足道。但是往往并不需要这么“重”的解决方法。
3. 线程：对每个请求，开一个新的线程进行处理。优点：容易，而且相比进程而言，对内核更加友好，因为线程使用的系统资源往往比进程要少。缺点：首先你的机器可能不支持线程。其次因为要考虑对共享资源的访问控制，很快线程编程就会变得非常复杂。

<!-- more -->

**Node.js的第二个基本观点是，每个请求用一个线程来处理的方式会耗费过多的内存。**(如同那张人尽皆知的图，与Nginx想比，Apache消耗了大量内存)

{% img /img/Memory_Apache_Nginx_Comparison.jpg 500 Memory Usage among Lighttpd, Ngnix And Apache %}

Apache是多线程的，它每次都会为新请求创建一个新线程（或者进程，这取决于怎么配置）。你可以看到随着并发连接数的增多，不仅消耗的内存越来越多，同时也需要更多的线程来服务这些同时发起请求的客户端。Ngnix和Node.js不是多线程的，因为线程和进程都会耗费过多的内存。Ngnix和Node.js是单线程的，但是是基于事件的。通过在一个线程中处理所有连接，从而消除因为创建多个线程或进程而消耗的系统资源。

###Node.js只为你的代码保留一个线程
它真的只有一个线程，你不能并行执行代码。如果你“sleep”一秒钟，将会阻塞整个server一秒钟：
``` javascript
while(new Date().getTime() < now + 1000) {
   // do nothing
}
```   

所以当上面的代码执行的时候，Node.js将不会响应任何来自客户端的请求，因为它只有一个线程在执行你的代码。或者假如你有一些CPU密集型的代码，比如图片缩放，这仍然会阻塞所有其他的请求。

###所有的代码都是并行执行的，除了你的代码
其实在一个线程里让代码并行执行是不可能的。然而，所有的I/O都是基于事件和异步的，那么就不会阻塞server。  

``` javascript
c.query(
   'SELECT SLEEP(20);',
   function (err, results, fields) {
     if (err) {
       throw err;
     }
     res.writeHead(200, {'Content-Type': 'text/html'});
     res.end('<html><head><title>Hello</title></head><body><h1>Return from async DB query</h1></body></html>');
     c.end();
    }
);
```

如果在一个请求处理中这么做，那么在查询数据库的时候，其他请求仍然能够被正确处理。

###为什么这么做是好的？我们什么时候从同步跳到异步的执行中？
同步执行有它的优点，因为这样简化了代码的编写。

在Node.js中，你不用担心后端发生了什么，只要在需要I/O的时候使用回调函数就行了。你的代码确保不会被打断，而且I/O不会阻塞其他的请求，也不会带来因为过多线程或进程导致的资源消耗。

让I/O异步执行是好的，因为I/O比大部分代码的执行更加昂贵，我们不应该仅仅在I/O的时候等在那里。
{% img /img/EventLoop.jpg 500 %}
事件轮询可以处理外部的事件，并且将他们转化为回调函数的调用。所以Node.js可以在I/O调用时从这个请求转向其他的请求。在I/O调用中，你的代码保存回调函数，并将控制权交给Node.js的运行时环境，回调函数将在I/O结束后被调用。

当然，在后端，有别的线程或者进程在执行I/O操作。然而这些并不会暴露在你的代码中，所以你并不用担心它们。但是你应该知道I/O操作，如数据库操作，或者其他的一些任务将会是异步执行的，这些线程的结果将通过事件轮询返回到每个请求的处理过程中。与Apache的模型相比，线程数和线程对资源的消耗下降了很多，因为我们并不需要为每个连接开一个线程。除非当你确实有些事情需要并行处理，才需要在此时开一个线程。而且在Node.js中，线程并不需要你来管理。

除了I/O调用外，Node.js希望所有的请求都能够快速返回，如：CPU密集型的工作应该交给另一个线程来处理。这个线程将会以事件的形式和你进行交互。这意味着，要想在后台有独立的线程存在，你只有使用事件这一种方法。基本上，所有会发布事件的对象都支持异步调用，而且你可以和这些阻塞中的代码进行交互，通过文件、socket或者子进程，所有的这些在Node.js中都叫做EventEmitter。我们可以使用这种方法来充分利用多核，另见：node-http-proxy。

**内部实现**   
在内部，libev为Node.js提供事件轮询，libeio提供线程池来支持异步I/O。如果想学习更多，可以看看libev的文档。

###如何在Node.js中进行异步操作
* 我们将函数作为参数进行传递，在需要的地方执行
* 匿名函数，或称为闭包，当事件I/O中结束时执行
* 回调计数，对于事件回调，我们并不能保证这些事件完成的顺序。所以如果你需要等待多个事件执行结束，通常你只需要保存一个并行操作的计数器，然后检查是否所有事件都执行结束。比如在回调中记录DB查询返回的个数。
* 事件轮询，如之前所述，你可以把阻塞代码转变为一个事件，让另一个线程来执行，并当执行结束后将结果返回。

就是这么简单！